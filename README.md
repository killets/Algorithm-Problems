# TODO

[100题里程碑](https://drive.google.com/open?id=0B0BJAgFiD4jINXdJQkRoZE9nVlE)

效率可以高起来的，2～3小时5题，平时那是在磨洋工

Not very clear, need to re-study

* 134,
* 94, 树的遍历的非递归算法，用stack存轨迹
* 15, 3SUM(2sum)时，two pointers的使用，双向移动
* 98, 类似树的中序遍历，存一个pre节点用于比较BST
* 130, Union-find
* 143, 属于“智力“题，考操作，算是我不太喜欢的题型
* 127, Word Ladder, 想破脑袋不会
* 114, 递归函数的理解和写法，实际运行栈图解分析
* 11, 双指针

Multiple algorithms, need to re-study

* 22,
* 53, 很有意思，有助于理解DP
* 93, backtracking 和 DFS的关系?
* 55, 别人算法里面的逻辑？贪心而不是DP?
* 80, 最多允许存2次
* 28, 他们怎样使得code如此简洁?
* 15, 2sum::two pointers的使用，o(n^2)->o(n)
* 90, 组合问题中有重复元素，DP，backtracking, etc.
* 119,120, DP的bottom up简化了问题，并且注意倒序可避免旧值覆盖
* 139, DP的另一种写法，倒着推，和LinearPartion很像
* 114, DFS然后别人第一种写法递归很简洁，第二种方法非递归且空间为o(1)
* 112, backtracking在tree中的应用，mark
* 129, 非常好的一题，分治时注意看如何将上面的值朝下传

Note

* 2和67避免重复写代码，使用 while(l1||l2||carry)
* 121使用一个for动态记录前面的最小，并且计算当前的最大差值，很巧妙
* 39 combination用backtracking，条件不是cnt而是nums[i]<=target
* 14, 看起来复杂，但实质简单
* 300, DP思想扫除定势，返回值并不一定是dp[n]，比如此处需要遍历找max dp[i]
* 53, maxEndinghere的想法很好，和300一样，最终结果是dp过程中的最大值maxSofar,并且可优化空间
* 9, 学到的是要think from 抽象的层面，不要去利用最底层的特性作为算法，此谓”算法“。
